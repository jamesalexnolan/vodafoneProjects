///VARIANT 1
<style id="vt586-style">

</style>

<script>
    /////VOXI TEMPLATE/////
    //*1 - polling function to wait for body to return true for node (issue only happens on first instance)
    //*2 - once true, mutation observer applied
    //*3 - Within mutation observer, we use URL conditions for both applying CSS and JS
    ///////NOTE - CSS WILL NEED AN ID TAG ADDED i.e. <style id="vt586-style">
    //*4 - if url conditions not met, CSS and JS not applied, MO is disconnected else MO fires and CSS is applied
    //*5 - using event listener "navigate" we are able to fire the mutation observer again 

    ////POLLING FUNCTION////
    //polling function config
    var vt586_nodeCheck_pxFuncFired = 0
    var vt586_nodeCheck_pxInterval = setInterval(vt586_nodeCheck_pxPollFunc, 100) //0.1 seconds * 20 = 2 seconds

    //polling function
    function vt586_nodeCheck_pxPollFunc() {
        vt586_nodeCheck_pxFuncFired += 1

        if (vt586_nodeCheck_pxFuncFired >= 20) {
            //try 20 times, if not found, clear px func
            clearInterval(vt586_nodeCheck_pxInterval)
        }

        if (document.body.nodeType === 1) {
            //clear polling when found
            clearInterval(vt586_nodeCheck_pxInterval)
            //MUTATION OBSERVER
            let vt586_observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    let vt586_oldValue = mutation.oldValue;
                    let vt586_newValue = mutation.target.textContent;
                    if (vt586_oldValue !== vt586_newValue) {
                        //MATCH URL CONDITION
                        if (document.location.pathname === '/sim-only-plans') {
                            //CODE HERE
                            var vt586_style_tag = document.querySelector('[id="vt586-style"]')
                            var vt586_inserted_banner = document.querySelector('.vt586-cro-banner')
                            if (!vt586_inserted_banner) {
                                vt586Func()
                                vt586_style_tag.innerHTML = '/*CSS HERE*/'
                            } else {
                                vt586_observer.disconnect()
                            }
                        } else {
                            vt586_observer.disconnect()
                            vt586_style_tag.innerHTML = ''
                        }
                    }
                });
            });

            vt586_observer.observe(document.body, {
                //characterDataOldValue: true,
                subtree: true,
                childList: true,
                //characterData: true,
                attributes: true
            })

            //reconnect mutation observer if user navigates back 
            window.navigation.addEventListener("navigate", (event) => {
                //start observing again
                vt586_observer.observe(document.body, {
                    //characterDataOldValue: true,
                    subtree: true,
                    childList: true,
                    //characterData: true,
                    attributes: true
                })
            })
        }
    }

    //function to call 
    function vt586Func() {
        //vars to refference 
        var vt586_original_banner = document.querySelector('div[role="banner"]')
        var vt586_new_banner = ''
        var vt586_inserted_banner = document.querySelector('.vt586-cro-banner')
        //insert banner if it doesn't exist
        if (!vt586_inserted_banner) {
            vt586_original_banner.innerHTML = vt586_new_banner
        }
    }
</script>

<body>
    <div class="vt586-cro-banner'">

    </div>
</body>

//VARIANT 2
<style id="vt586-style">

</style>

<script>
    /////VOXI TEMPLATE/////
    //*1 - polling function to wait for body to return true for node (issue only happens on first instance)
    //*2 - once true, mutation observer applied
    //*3 - Within mutation observer, we use URL conditions for both applying CSS and JS
    ///////NOTE - CSS WILL NEED AN ID TAG ADDED i.e. <style id="vt586-style">
    //*4 - if url conditions not met, CSS and JS not applied, MO is disconnected else MO fires and CSS is applied
    //*5 - using event listener "navigate" we are able to fire the mutation observer again 

    ////POLLING FUNCTION////
    //polling function config
    var vt586_nodeCheck_pxFuncFired = 0;
    var vt586_nodeCheck_pxInterval = setInterval(vt586_nodeCheck_pxPollFunc, 100); //0.1 seconds * 20 = 2 seconds

    //polling function
    function vt586_nodeCheck_pxPollFunc() {
        vt586_nodeCheck_pxFuncFired += 1;

        if (vt586_nodeCheck_pxFuncFired >= 20) {
            //try 20 times, if not found, clear px func
            clearInterval(vt586_nodeCheck_pxInterval);
        }

        if (document.body.nodeType === 1) {
            //clear polling when found
            clearInterval(vt586_nodeCheck_pxInterval);
            //MUTATION OBSERVER
            let vt586_observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    let vt586_oldValue = mutation.oldValue;
                    let vt586_newValue = mutation.target.textContent;
                    if (vt586_oldValue !== vt586_newValue) {
                        //MATCH URL CONDITION
                        if (document.location.pathname === '/sim-only-plans') {
                            //CODE HERE
                            var vt586_style_tag = document.querySelector('[id="vt586-style"]')
                            var vt586_inserted_banner = document.querySelector('.vt586-cro-banner')
                            if (!vt586_inserted_banner) {
                                vt586Func()
                                vt586_style_tag.innerHTML = '/*CSS HERE*/'
                            } else {
                                vt586_observer.disconnect()
                            }
                        } else {
                            vt586_observer.disconnect()
                            vt586_style_tag.innerHTML = ''
                        }
                    }
                });
            });

            vt586_observer.observe(document.body, {
                //characterDataOldValue: true,
                subtree: true,
                childList: true,
                //characterData: true,
                attributes: true
            });

            //reconnect mutation observer if user navigates back 
            window.navigation.addEventListener("navigate", (event) => {
                //start observing again
                vt586_observer.observe(document.body, {
                    //characterDataOldValue: true,
                    subtree: true,
                    childList: true,
                    //characterData: true,
                    attributes: true
                });
            })
        }
    }

    //function to call 
    function vt586Func() {
        //vars to refference 
        var vt586_original_banner = document.querySelector('div[role="banner"]')
        var vt586_new_banner = ''
        var vt586_inserted_banner = document.querySelector('.vt586-cro-banner')
        //insert banner if it doesn't exist
        if (!vt586_inserted_banner) {
            vt586_original_banner.innerHTML = vt586_new_banner
        }
    }
</script>

<body>
    <div class="vt586-cro-banner'">

    </div>
</body>